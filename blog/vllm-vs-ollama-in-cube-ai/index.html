<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>vLLM vs Ollama in Cube AI: Choosing the Right LLM Backend for Your Use Case - Ultraviolet</title>
  <meta name="title" content="vLLM vs Ollama in Cube AI: Choosing the Right LLM Backend for Your Use Case - Ultraviolet" />
  <meta name="description" content="This post explains how Cube AI lets you swap between vLLM and Ollama as LLM backends using a single configuration flag, and walks through the trade-offs in performance, scalability, and deployment so you can pick the best inference engine for your use case." />

  <link rel="canonical" href="https://www.ultraviolet.rs/blog/vllm-vs-ollama-in-cube-ai/" />

  <meta property="og:type" content="article" />
  <meta property="og:site_name" content="Ultraviolet" />
  <meta property="og:url" content="https://www.ultraviolet.rs/blog/vllm-vs-ollama-in-cube-ai" />
  <meta property="og:title" content="vLLM vs Ollama in Cube AI: Choosing the Right LLM Backend for Your Use Case" />
  <meta property="og:description" content="This post explains how Cube AI lets you swap between vLLM and Ollama as LLM backends using a single configuration flag, and walks through the trade-offs in performance, scalability, and deployment so you can pick the best inference engine for your use case." />
  <meta property="og:image" content="https://www.ultraviolet.rs/img/vllm-vs-ollama-in-cube-ai/vllm_vs_ollama_cover.png" />

  
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="vLLM vs Ollama in Cube AI: Choosing the Right LLM Backend for Your Use Case" />
  <meta name="twitter:description" content="This post explains how Cube AI lets you swap between vLLM and Ollama as LLM backends using a single configuration flag, and walks through the trade-offs in performance, scalability, and deployment so you can pick the best inference engine for your use case." />
  <meta name="twitter:image" content="https://www.ultraviolet.rs/img/vllm-vs-ollama-in-cube-ai/vllm_vs_ollama_cover.png" />


  
  <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "headline": "vLLM vs Ollama in Cube AI: Choosing the Right LLM Backend for Your Use Case",
        "image": "https:\/\/www.ultraviolet.rs\/img\/vllm-vs-ollama-in-cube-ai\/vllm_vs_ollama_cover.png",
        "datePublished": "2026-02-11",
        "author": {
          "@type": "Person",
          "name": "Washington Kamadi"
        },
        "description": "This post explains how Cube AI lets you swap between vLLM and Ollama as LLM backends using a single configuration flag, and walks through the trade-offs in performance, scalability, and deployment so you can pick the best inference engine for your use case."
      }
    </script>

  
  <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <link rel="shortcut icon" href="/favicon.ico" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <meta name="apple-mobile-web-app-title" content="Ultraviolet" />
  <link rel="manifest" href="/site.webmanifest" />

  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Outfit&display=swap" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lexend&display=swap" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Sen&display=swap" />

  
  <link rel="stylesheet" type="text/css" href="/style.css" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous" />
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" rel="stylesheet" />
  <link rel="stylesheet" type="text/css"
    href="https://cdn.jsdelivr.net/npm/cookieconsent@3/build/cookieconsent.min.css" />

  
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>

  <style>
    .navbar-nav .nav-link {
      color: black !important;
    }

     
    .markdown-content img {
      max-width: 100%;
      height: auto;
      border-radius: 8px;
      margin: 1.5rem auto;
      display: block;
    }

    .markdown-content h2,
    .markdown-content h3 {
      margin-top: 2rem;
      margin-bottom: 1rem;
      font-weight: 700;
      color: #212529;
    }

    .markdown-content p {
      margin-bottom: 1.25rem;
      line-height: 1.8;
      font-size: 1.1rem;
      color: #333;
    }

    .markdown-content pre {
      border-radius: 6px;
      padding: 1rem;
    }

    .markdown-content blockquote {
      border-left: 4px solid #ddd;
      padding-left: 1rem;
      color: #555;
      margin: 1.5rem 0;
      font-style: italic;
    }

    .markdown-content table {
      border-collapse: collapse;
      width: 100%;
      margin: 1.5rem 0;
    }

    .markdown-content th,
    .markdown-content td {
      border: 1px solid #ddd;
      padding: 0.6rem 0.8rem;
    }

    .markdown-content th {
      background: #f5f5f5;
      font-weight: 600;
    }

    .code-wrapper {
      position: relative;
      margin-bottom: 1.5rem;
    }

    .code-wrapper pre {
      margin-bottom: 0;
    }

    .copy-button {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      padding: 0.2rem 0.5rem;
      font-size: 0.85rem;
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      cursor: pointer;
      opacity: 0;
      transition: all 0.2s ease;
      z-index: 10;
    }

    .code-wrapper:hover .copy-button {
      opacity: 1;
    }

    .copy-button:hover {
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
    }

    .copy-button.copied {
      background: #198754;
      border-color: #198754;
      color: #fff;
      opacity: 1;
    }

     
    .markdown-content pre[class*="language-mermaid"] {
      background: transparent;
      padding: 0;
      border: none;
    }

    .markdown-content code[class*="language-mermaid"] {
      display: none;
    }

    .mermaid {
      display: flex;
      justify-content: center;
      margin: 1.5rem 0;
      background: #f8f9fa;
      border-radius: 8px;
      padding: 1.5rem;
    }
  </style>
</head>

<body>
  
  <nav class="navbar navbar-expand-lg fixed-top" style="background-color: #ffffff">
    <div class="container">
      <a class="navbar-brand" href="/">
        <img src="/img/logos/UltraViolet_logo-horizontal.svg" alt="Magistrala" height="30" width="250" />
      </a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"
        aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarNav">
        <ul class="navbar-nav ms-auto">
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="productsDropdown" role="button" data-bs-toggle="dropdown"
              aria-expanded="false" style="color: black">
              PRODUCTS
            </a>
            <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="productsDropdown">
              <li><a class="dropdown-item" href="https://prism.ultraviolet.rs"
                  title="Prism AI Multi-Party Confidential Computation Orchestration Platform" target="_blank">PRISM
                  AI</a></li>
              <li><a class="dropdown-item" href="/cocos"
                  title="Cocos AI Open Source Confidential Computing Platform">COCOS AI</a></li>
              <li><a class="dropdown-item" href="/cube"
                  title="Cube AI Privacy-Preserving LLM Deployment Framework with Confidential Computing">CUBE AI</a>
              </li>
              <li>
                <a class="dropdown-item" href="/products">All Products</a>
              </li>
            </ul>
          </li>
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown"
              aria-expanded="false" style="color: black">
              DOCUMENTATION
            </a>
            <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
              <li>
                <a class="dropdown-item" href="https://docs.prism.ultraviolet.rs/" target="_blank">PRISM AI</a>
              </li>
              <li>
                <a class="dropdown-item" href="https://docs.cocos.ultraviolet.rs/" target="_blank">COCOS AI</a>
              </li>
              <li>
                <a class="dropdown-item" href="https://docs.cube.ultraviolet.rs/" target="_blank">CUBE AI</a>
              </li>
            </ul>
          </li>
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="projectsDropdown" role="button" data-bs-toggle="dropdown"
              aria-expanded="false" style="color: black">
              PROJECTS
            </a>
            <ul class="dropdown-menu" aria-labelledby="projectsDropdown">
              <li>
                <a class="dropdown-item" href="/projects/confidential6g">CONFIDENTIAL6G</a>
              </li>
              <li>
                <a class="dropdown-item" href="/projects/elastic">ELASTIC</a>
              </li>
              <li>
                <a class="dropdown-item" href="/projects/titan">TITAN</a>
              </li>
              <li>
                <a class="dropdown-item" href="/projects">All Projects</a>
              </li>
            </ul>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/company" style="color: black">COMPANY</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/careers" style="color: black">CAREERS</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/contact" style="color: black">CONTACT</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/blog" style="color: black">BLOG</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/ultravioletrs" target="_blank" style="color: black"><i
                class="fab fa-github"></i></a>
          </li>
        </ul>
      </div>
    </div>
  </nav>

  <article class="container py-5 mt-5">
    <div class="row justify-content-center">
      <div class="col-lg-8">
        
        <div class="mb-4">
          <a href="/blog" class="text-decoration-none text-muted"><i class="fas fa-arrow-left me-2"></i>Back to Blog</a>
        </div>

        <div class="mb-3">
          <span class="badge bg-primary fs-6"></span>
          
        </div>

        <h1 class="display-4 fw-bold mb-4">vLLM vs Ollama in Cube AI: Choosing the Right LLM Backend for Your Use Case</h1>

        <div class="d-flex align-items-center mb-4 pb-4 border-bottom">
          <img src="https://avatars.githubusercontent.com/u/43080232?v=4&amp;size=64" alt="Washington Kamadi" class="rounded-circle me-3" width="60" height="60"
            loading="lazy" onerror="this.onerror=null; this.src = '/assets/team/default-avatar.jpg'" />
          <div>
            <div class="fw-bold fs-5">Washington Kamadi</div>
            <div class="text-muted">
              February 11, 2026 · 17 min read
            </div>
          </div>
        </div>

        
        <img src="/img/vllm-vs-ollama-in-cube-ai/vllm_vs_ollama_cover.png" alt="vLLM vs Ollama in Cube AI: Choosing the Right LLM Backend for Your Use Case" class="img-fluid rounded mb-5 w-100 shadow-sm" loading="lazy"
          onerror="this.style.display = 'none'" />
        

        <div class="markdown-content"><p>Selecting the right Large Language Model (LLM) backend is no longer just an infrastructure decision — it directly impacts latency, throughput, operational cost, scalability, and developer velocity. The choice of inference engine determines how quickly your models respond under load, how efficiently your GPU resources are utilized, and how much operational overhead your team must absorb on an ongoing basis. Getting this decision wrong can mean over-provisioning expensive hardware for a workload that doesn't need it, or under-serving users with an engine that can't keep up with production traffic.</p>
<p>Cube AI is intentionally designed with <strong>backend modularity</strong> at its core, allowing teams to switch between inference engines without changing any application logic, rewriting API integrations, or modifying client SDKs. Whether you prioritize <strong>GPU-accelerated performance</strong> for high-concurrency production workloads or <strong>lightweight local deployments</strong> for development, edge computing, and confidential environments, Cube AI supports both paradigms through two production-ready backends:</p>
<ul>
<li><strong>vLLM</strong> — optimized for high-throughput, GPU-driven inference with continuous batching and explicit memory management</li>
<li><strong>Ollama</strong> — a flexible, developer-friendly runtime designed for local, hybrid, and resource-constrained environments</li>
</ul>
<p>The architectural takeaway is simple:</p>
<blockquote>
<p><strong>In Cube AI, the LLM backend is a swappable module behind a single environment variable.</strong></p>
</blockquote>
<!-- raw HTML omitted -->
<h2 id="backend-selection-architecture">Backend Selection Architecture</h2>
<p>Cube AI routes all inference traffic through a <strong>backend-agnostic agent proxy</strong>. Rather than coupling application code directly to a specific inference engine's API, the proxy sits between the application layer and the backend, forwarding requests to whichever inference engine is currently configured. This means the entire system — from the frontend client to the guardrails pipeline — remains completely unaware of whether it is talking to vLLM or Ollama on the other side.</p>
<p>The backend target is controlled by a single environment variable:</p>
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;"><code><span style="display:flex;"><span>UV_CUBE_AGENT_TARGET_URL=http://ollama:11434
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># OR</span>
</span></span><span style="display:flex;"><span>UV_CUBE_AGENT_TARGET_URL=http://vllm:8000
</span></span></code></pre><p>This variable defaults to <code>http://localhost:11434</code> (Ollama). The Makefile provides convenient targets that automatically update this variable and launch the appropriate Docker Compose profile, so switching backends is operationally trivial:</p>
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;"><code><span style="display:flex;"><span>up-ollama: config-ollama
</span></span><span style="display:flex;"><span>up-vllm:   config-vllm
</span></span></code></pre><p>There is no need for application rewrites, routing changes, or SDK updates. The swap happens entirely at the infrastructure level. You simply reconfigure the environment variable and redeploy — the application continues to function exactly as before, now backed by a different inference engine.</p>
<h3 id="why-this-matters-architecturally">Why This Matters Architecturally</h3>
<p>This design creates a clean separation between four distinct layers of the system, each of which can evolve independently:</p>
<ul>
<li><strong>Application layer</strong> — the user-facing services and clients that consume LLM responses</li>
<li><strong>Guardrails</strong> — the NeMo Guardrails pipeline that enforces safety policies, sensitive data detection, and content filtering</li>
<li><strong>Proxy routing</strong> — the dynamic router that directs traffic based on configurable rules such as headers, paths, and priority levels</li>
<li><strong>Inference engine</strong> — the actual LLM backend (vLLM or Ollama) that performs model inference</li>
</ul>
<p>The agent service acts as a reverse proxy, forwarding requests to the configured backend. It handles authentication at the proxy boundary and maintains efficient connection management under load, so the backend remains completely invisible to the application. Whether the underlying engine is vLLM processing requests with continuous batching on a GPU cluster or Ollama running sequentially on a CPU-only node, the API contract remains identical.</p>
<p>This separation is critical for several real-world operational scenarios: multi-environment deployments where staging runs Ollama and production runs vLLM, gradual GPU rollouts where teams incrementally shift traffic to GPU-backed inference, cost optimization experiments where teams compare per-token costs across backends, and performance experimentation where teams benchmark different engines under realistic workloads.</p>
<hr>
<h2 id="performance-benchmarks-architectural-expectations">Performance Benchmarks (Architectural Expectations)</h2>
<p>While exact performance numbers will vary depending on the specific model, GPU class, input sequence length, and concurrency level, the underlying architecture of each engine reveals clear and predictable performance behavior. Understanding these architectural characteristics helps teams make informed backend decisions before committing to expensive hardware.</p>
<h3 id="throughput">Throughput</h3>
<p><strong>vLLM</strong></p>
<p>vLLM was purpose-built for high-throughput inference. Its continuous batching engine dynamically groups incoming requests together and processes them in parallel on the GPU, which dramatically increases the number of tokens generated per second compared to sequential processing. This design means that vLLM actually becomes more efficient as concurrency increases — the GPU stays saturated with useful work rather than idling between requests. For production APIs serving many concurrent users, this translates directly into lower cost per token and higher overall system utilization.</p>
<p><strong>Ollama</strong></p>
<p>Ollama uses a sequential processing model, handling one request at a time through the inference pipeline. While this approach is simpler and more predictable, it means that throughput scales linearly with hardware rather than benefiting from batching efficiencies. That said, Ollama performs excellently for low-to-moderate concurrency workloads, and its predictable performance characteristics make it easier to reason about resource requirements on smaller nodes.</p>
<p><strong>Expected Winner: vLLM</strong> (by design — continuous batching is fundamentally more throughput-efficient than sequential processing)</p>
<h3 id="latency">Latency</h3>
<p>When measuring single-request latency in isolation, Ollama performs well for individual prompts because there is no batching overhead. The request goes directly into the model and comes back with minimal scheduling delay. However, this advantage diminishes rapidly as concurrency increases.</p>
<p>vLLM shines under load due to its batching efficiency. Because it processes multiple requests simultaneously, the amortized latency per request can actually decrease as more requests arrive — the GPU processes a batch of requests in roughly the same time it would take to process a single one.</p>
<p><strong>Important Insight:</strong>
If your system experiences burst traffic patterns — where many requests arrive in a short window — vLLM's latency often <em>improves</em> relative to sequential engines. While a sequential engine queues requests and processes them one at a time (leading to linearly increasing wait times), vLLM absorbs the burst into a batch and processes it as a unit.</p>
<h3 id="memory-usage">Memory Usage</h3>
<p><strong>vLLM</strong></p>
<p>vLLM provides explicit, fine-grained control over GPU memory allocation. In the Cube AI Docker Compose configuration (<code>docker/vllm-compose.yml</code>), this is configured with:</p>
<pre><code>--gpu-memory-utilization 0.85
--max-model-len 1024
</code></pre>
<p>The <code>--gpu-memory-utilization 0.85</code> flag tells vLLM to use up to 85% of available GPU memory, reserving the remaining 15% as a safety margin. The <code>--max-model-len 1024</code> flag caps the maximum sequence length, which directly controls the KV-cache memory footprint. This level of explicit control is extremely valuable for capacity planning, because you can precisely predict how much GPU memory your deployment will consume and plan your infrastructure accordingly.</p>
<p><strong>Ollama</strong></p>
<p>Ollama takes a different approach, handling memory management automatically based on the loaded model's requirements. The memory footprint is model-dependent, and Ollama dynamically allocates and releases memory as models are loaded and unloaded. While this means less operational tuning overhead — you don't need to carefully configure memory utilization percentages — it also means less predictability in resource consumption, which can complicate capacity planning in tightly constrained environments.</p>
<p><strong>Trade-off:</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">Goal</th>
<th style="text-align:left">Better Choice</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Deterministic GPU planning</td>
<td style="text-align:left">vLLM</td>
</tr>
<tr>
<td style="text-align:left">Operational simplicity</td>
<td style="text-align:left">Ollama</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="vllm-high-performance-gpu-inference">vLLM: High-Performance GPU Inference</h2>
<p>Cube AI deploys vLLM using the official OpenAI-compatible container image:</p>
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;"><code><span style="display:flex;"><span>vllm/vllm-openai:v0.10.2
</span></span></code></pre><p>This image provides an OpenAI-compatible API server out of the box, which means any client or SDK that speaks the OpenAI protocol (specifically the <code>/v1/chat/completions</code> and <code>/v1/models</code> endpoints) can interact with vLLM without modification. The deployment requires the NVIDIA container runtime, as vLLM is designed exclusively for GPU-accelerated inference — it leverages CUDA for all compute operations and is not intended for CPU-only environments.</p>
<p>Under the hood, vLLM implements continuous batching, which dynamically groups incoming requests for parallel processing on the GPU. It loads models directly from HuggingFace by model identifier, caching them in a persistent Docker volume (<code>vllm-cache</code>) so that subsequent restarts don't require re-downloading the model weights. The model is defined at startup time through the <code>VLLM_MODEL</code> environment variable:</p>
<pre><code>VLLM_MODEL=microsoft/DialoGPT-medium
</code></pre>
<blockquote>
<p>Model changes require a container restart — this is a deliberate design choice that stabilizes production behavior. By binding the model to the container lifecycle, vLLM ensures that the loaded model is always consistent and predictable, avoiding the complexity of runtime model swapping in performance-critical deployments.</p>
</blockquote>
<h3 id="when-vllm-is-the-right-choice">When vLLM Is the Right Choice</h3>
<p>Choose vLLM when your system demands high tokens-per-second throughput, multi-tenant inference where many users share a single GPU-backed endpoint, or maximum GPU utilization for cost efficiency. vLLM is particularly well-suited for production-scale APIs where predictable latency under load is a hard requirement, because the continuous batching engine ensures that response times remain stable even as request concurrency increases.</p>
<p>Typical environments where vLLM excels include enterprise AI platforms serving thousands of internal users, internal copilot systems integrated into developer workflows, retrieval-augmented generation (RAG) pipelines that need fast inference alongside document retrieval, and customer-facing LLM APIs where SLA commitments require consistent performance characteristics.</p>
<hr>
<h2 id="ollama-lightweight-and-operationally-flexible">Ollama: Lightweight and Operationally Flexible</h2>
<p>Cube AI ships Ollama using the official container image, tracking the latest stable release:</p>
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;"><code><span style="display:flex;"><span>ollama/ollama:latest
</span></span></code></pre><p>When the Ollama profile starts, Cube AI automatically pulls a curated set of default models through sidecar containers that execute <code>ollama pull</code> against the running Ollama instance. These default models provide a ready-to-use baseline for chat, code generation, and text embedding:</p>
<ul>
<li><code>llama3.2:3b</code> — a general-purpose conversational model</li>
<li><code>starcoder2:3b</code> — a code-oriented model for programming tasks</li>
<li><code>nomic-embed-text:v1.5</code> — a text embedding model for semantic search and RAG pipelines</li>
</ul>
<h3 id="major-strength-runtime-model-management">Major Strength: Runtime Model Management</h3>
<p>One of Ollama's most significant advantages over vLLM is its ability to manage models at runtime without requiring a service restart. While vLLM binds its model to the container lifecycle (the model is loaded at startup and cannot be changed without restarting), Ollama provides a full model management API that allows you to pull new models from the Ollama registry on the fly, delete unused models to reclaim disk space, and push custom or fine-tuned models to a private registry. This capability dramatically improves developer velocity, because teams can experiment with different models — swapping between Llama, Mistral, CodeLlama, and others — without any downtime or infrastructure changes.</p>
<h3 id="hardware-flexibility">Hardware Flexibility</h3>
<p>Ollama is designed to run across a wide range of hardware configurations, which makes it far more versatile than vLLM in terms of deployment targets:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Capability</th>
<th style="text-align:left">Ollama</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CPU-only</td>
<td style="text-align:left">Supported</td>
</tr>
<tr>
<td style="text-align:left">NVIDIA GPU</td>
<td style="text-align:left">Supported</td>
</tr>
<tr>
<td style="text-align:left">AMD GPU (ROCm)</td>
<td style="text-align:left">Supported</td>
</tr>
<tr>
<td style="text-align:left">Edge devices</td>
<td style="text-align:left">Supported</td>
</tr>
</tbody>
</table>
<p>This broad hardware compatibility makes Ollama extremely attractive for deployment scenarios where GPU availability cannot be guaranteed. Confidential Virtual Machines (CVMs) running in Trusted Execution Environments may not have GPU passthrough configured, edge inference nodes may be running on commodity ARM hardware, on-premises deployments may need to operate on whatever hardware is available, and secure or air-gapped environments may have strict procurement constraints that limit GPU options. In all of these cases, Ollama's ability to run on CPU-only nodes provides a viable path to deploying LLM inference without GPU dependencies.</p>
<hr>
<h2 id="deployment-scenarios-and-trade-offs">Deployment Scenarios and Trade-offs</h2>
<p>To make the backend choice more concrete, here are four common deployment scenarios and the reasoning behind each recommendation.</p>
<h3 id="scenario-1--enterprise-production-api">Scenario 1 — Enterprise Production API</h3>
<p><strong>Recommended: vLLM</strong></p>
<p>When you're building a production API that serves multiple teams, departments, or external customers, vLLM is the clear choice. Continuous batching ensures that the GPU stays efficiently utilized even under variable load patterns, and the OpenAI-compatible API means that existing client integrations — whether they use the official OpenAI SDK, LangChain, or custom HTTP clients — work without modification. The predictable scaling behavior of vLLM allows infrastructure teams to capacity-plan with confidence, knowing exactly how the system will behave as request volumes grow.</p>
<h3 id="scenario-2--confidential--air-gapped-environment">Scenario 2 — Confidential / Air-Gapped Environment</h3>
<p><strong>Recommended: Ollama</strong></p>
<p>In confidential computing environments — such as CVMs running inside Trusted Execution Environments (TEEs) — or air-gapped networks where external connectivity is restricted, Ollama's operational characteristics become decisive advantages. Its runtime model management means that models can be pre-loaded, swapped, or updated without restarting the service, which is particularly important in environments where service restarts trigger re-attestation or security re-validation. Ollama's hardware flexibility means it can run on whatever compute is available inside the secure enclave, and its simpler dependency chain makes offline deployment and model provisioning significantly easier to manage.</p>
<h3 id="scenario-3--developer-sandbox">Scenario 3 — Developer Sandbox</h3>
<p><strong>Recommended: Ollama</strong></p>
<p>For development and experimentation environments, Ollama's minimal startup friction makes it the natural choice. Developers can spin up a local Ollama instance in seconds, pull different models to test against, and iterate rapidly without needing access to GPU infrastructure. The ability to dynamically swap models at runtime is especially valuable during the prototyping phase, where teams are evaluating which model best fits their use case before committing to a production deployment.</p>
<h3 id="scenario-4--high-concurrency-saas">Scenario 4 — High-Concurrency SaaS</h3>
<p><strong>Recommended: vLLM</strong></p>
<p>When building a multi-tenant SaaS product where hundreds or thousands of concurrent users are generating inference requests simultaneously, sequential processing engines become bottlenecks almost immediately. Each new concurrent request adds to the queue, and response times degrade linearly. vLLM's continuous batching architecture is specifically designed for this scenario — it absorbs concurrent requests into batches and processes them in parallel, maintaining stable response times even as concurrency scales.</p>
<hr>
<h2 id="cost-analysis-and-resource-requirements">Cost Analysis and Resource Requirements</h2>
<p>Understanding the cost profile of each backend is essential for making financially sound infrastructure decisions, especially as LLM workloads grow from experimental to production scale.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Dimension</th>
<th style="text-align:left">vLLM</th>
<th style="text-align:left">Ollama</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Upfront Cost</strong></td>
<td style="text-align:left">High (requires NVIDIA GPUs, GPU orchestration)</td>
<td style="text-align:left">Low (runs on CPU, standard instances)</td>
</tr>
<tr>
<td style="text-align:left"><strong>Cost per Token</strong></td>
<td style="text-align:left">Lower at scale (continuous batching)</td>
<td style="text-align:left">Higher under load (sequential processing)</td>
</tr>
<tr>
<td style="text-align:left"><strong>Idle Cost</strong></td>
<td style="text-align:left">Expensive (reserved GPU capacity)</td>
<td style="text-align:left">Minimal (standard compute)</td>
</tr>
<tr>
<td style="text-align:left"><strong>Best For</strong></td>
<td style="text-align:left">Sustained high traffic, predictable workloads</td>
<td style="text-align:left">Early-stage, sporadic traffic, PoC</td>
</tr>
<tr>
<td style="text-align:left"><strong>Scaling Model</strong></td>
<td style="text-align:left">Vertical (GPU utilization)</td>
<td style="text-align:left">Horizontal (more instances)</td>
</tr>
<tr>
<td style="text-align:left"><strong>Infrastructure</strong></td>
<td style="text-align:left">Specialized (NVIDIA runtime, GPU drivers)</td>
<td style="text-align:left">Standard (no specialized requirements)</td>
</tr>
</tbody>
</table>
<h3 id="vllm-cost-profile">vLLM Cost Profile</h3>
<p>vLLM carries a higher upfront infrastructure cost because it requires dedicated NVIDIA GPUs, GPU-aware container orchestration (the Docker Compose configuration specifies <code>runtime: nvidia</code> with all GPU capabilities reserved), and careful capacity planning to ensure GPU memory is allocated efficiently. However, the cost per token at scale is significantly lower than sequential engines, because continuous batching maximizes GPU utilization — you're extracting more useful inference work from each dollar of GPU compute.</p>
<p>The key consideration is utilization: idle GPUs are expensive. If your vLLM instance sits idle for large portions of the day because traffic is light or sporadic, you're paying for reserved GPU capacity that isn't generating value. vLLM is most cost-effective when GPU utilization is consistently high, which typically means production workloads with steady or predictable traffic patterns.</p>
<h3 id="ollama-cost-profile">Ollama Cost Profile</h3>
<p>Ollama offers a much lower entry cost because it can run on standard CPU nodes, mixed GPU fleets (including AMD GPUs via ROCm), and smaller cloud instances. There is no requirement for specialized GPU drivers, NVIDIA container runtime, or dedicated GPU reservations. This makes Ollama an excellent choice for early-stage projects, proof-of-concept deployments, and environments where budget constraints preclude GPU infrastructure.</p>
<p>The trade-off is that the marginal cost per token under heavy load is higher than vLLM, because Ollama's sequential processing model cannot achieve the same throughput per hardware unit. As traffic grows, you'll need to scale horizontally (more Ollama instances) rather than relying on the batching efficiency of a single GPU-backed vLLM deployment.</p>
<h3 id="strategic-insight">Strategic Insight</h3>
<p><strong>Start with Ollama. Move to vLLM when concurrency justifies GPU spend.</strong></p>
<p>This migration path is one of Cube AI's core design advantages. Because the backend is abstracted behind the agent proxy and a single environment variable, graduating from Ollama to vLLM is a configuration change — not a rewrite. Teams can validate their LLM use case with minimal infrastructure investment, then scale to GPU-accelerated inference when the workload demands it.</p>
<hr>
<h2 id="integration-patterns-with-cube-ai">Integration Patterns with Cube AI</h2>
<h3 id="proxy-level-api-exposure">Proxy-Level API Exposure</h3>
<p>The Cube AI proxy exposes inference endpoints in two API formats, giving clients flexibility in how they interact with the system.</p>
<p><strong>OpenAI-Compatible</strong></p>
<pre><code>POST /{domainID}/v1/chat/completions
GET  /{domainID}/v1/models
</code></pre>
<p>These endpoints work with both vLLM and Ollama backends. vLLM natively speaks the OpenAI protocol, while Ollama also supports OpenAI-compatible endpoints. The <code>{domainID}</code> prefix allows the proxy to route requests to the correct domain-scoped backend instance, enabling multi-tenant deployments where different organizations or teams use separate inference endpoints.</p>
<p><strong>Ollama-Native</strong></p>
<pre><code>POST /api/chat
POST /api/generate
GET  /api/tags
</code></pre>
<p>These Ollama-native endpoints are available when Ollama is the active backend. Regardless of which backend is active, Cube AI provides OpenAI-compatible endpoints, so clients interact with a consistent API regardless of whether the underlying engine is vLLM or Ollama.</p>
<h3 id="guardrails-integration">Guardrails Integration</h3>
<p>Cube AI includes a guardrails pipeline built on NVIDIA's NeMo Guardrails framework, providing safety policies, sensitive data detection, and content filtering for all inference traffic. The guardrails system works seamlessly with both vLLM and Ollama backends — because the guardrails sit upstream of the agent proxy, they are completely backend-agnostic. Regardless of which inference engine is active, all chat traffic passes through the same guardrails pipeline before reaching the LLM, ensuring consistent safety and compliance enforcement across backend configurations.</p>
<h3 id="hal-beyond-containers">HAL: Beyond Containers</h3>
<p>Cube AI doesn't stop at Docker containers. Both vLLM and Ollama are fully packaged inside the Hardware Abstraction Layer (HAL), which is built on Buildroot to produce minimal Linux images for bare-metal and CVM deployments. Each backend includes:</p>
<ul>
<li><strong>Systemd service units</strong> — <code>ollama.service</code> and <code>vllm.service</code> provide proper service lifecycle management with automatic restart, journal logging, and dedicated service users (<code>ollama</code> and <code>vllm</code> respectively)</li>
<li><strong>SysV init scripts</strong> — <code>S96ollama</code> and <code>S96vllm</code> provide backward-compatible init support for environments that don't use systemd</li>
<li><strong>Auto model provisioning</strong> — the Ollama HAL package includes a <code>pull-models.sh</code> script that automatically pulls configured models on first boot, with retry logic (up to 20 attempts with 5-second backoff) to handle slow network conditions in CVM environments</li>
</ul>
<p>This HAL integration enables bare-metal CVM deployments where Docker is not available or not permitted — a critical advantage for confidential AI environments where the entire software stack must run inside a hardware-attested Trusted Execution Environment.</p>
<hr>
<h2 id="side-by-side-comparison">Side-by-Side Comparison</h2>
<table>
<thead>
<tr>
<th style="text-align:left">Dimension</th>
<th style="text-align:left">Ollama</th>
<th style="text-align:left">vLLM</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Version</strong></td>
<td style="text-align:left">0.12.3</td>
<td style="text-align:left">0.10.2</td>
</tr>
<tr>
<td style="text-align:left"><strong>API</strong></td>
<td style="text-align:left">Native <code>/api/*</code></td>
<td style="text-align:left">OpenAI <code>/v1/*</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>GPU</strong></td>
<td style="text-align:left">Optional</td>
<td style="text-align:left">Required (NVIDIA)</td>
</tr>
<tr>
<td style="text-align:left"><strong>CPU Support</strong></td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">No</td>
</tr>
<tr>
<td style="text-align:left"><strong>Model Mgmt</strong></td>
<td style="text-align:left">Runtime</td>
<td style="text-align:left">Startup</td>
</tr>
<tr>
<td style="text-align:left"><strong>Batching</strong></td>
<td style="text-align:left">Sequential</td>
<td style="text-align:left">Continuous</td>
</tr>
<tr>
<td style="text-align:left"><strong>Default Model</strong></td>
<td style="text-align:left"><code>llama3.2:3b</code></td>
<td style="text-align:left"><code>DialoGPT-medium</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>Memory Config</strong></td>
<td style="text-align:left">Automatic</td>
<td style="text-align:left">Explicit</td>
</tr>
<tr>
<td style="text-align:left"><strong>Guardrails</strong></td>
<td style="text-align:left">Native adapter</td>
<td style="text-align:left">Via OpenAI</td>
</tr>
<tr>
<td style="text-align:left"><strong>Compose Profile</strong></td>
<td style="text-align:left">default</td>
<td style="text-align:left">vllm</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="the-architectural-insight-that-matters-most">The Architectural Insight That Matters Most</h2>
<p>Cube AI treats inference engines like <strong>infrastructure plugins</strong> — not hard dependencies, not vendor lock-in points, but interchangeable modules that can be swapped, upgraded, or replaced without rippling changes through the rest of the system.</p>
<p>This is possible because the agent proxy creates a clean abstraction boundary between the application and the inference engine. The proxy handles authentication, header management, connection pooling, and request forwarding, while the dynamic router directs traffic based on configurable rules. The application code, the guardrails pipeline, and the client SDKs never communicate directly with vLLM or Ollama — they talk to the proxy, and the proxy talks to whatever backend is currently configured.</p>
<p>The practical consequence of this design is significant: <strong>your application never needs to know which backend is running.</strong> This dramatically reduces platform risk, because you're never locked into a single inference engine's API, deployment model, or hardware requirements. If a better engine emerges, or if your requirements change, the migration is a configuration change — not an architecture overhaul.</p>
<hr>
<h2 id="decision-framework">Decision Framework</h2>
<p><strong>Choose vLLM if:</strong></p>
<ul>
<li>You are operating at production scale with sustained or growing traffic, where GPU efficiency translates directly into cost savings</li>
<li>Latency consistency under concurrent load is a hard requirement, such as customer-facing APIs with SLA commitments</li>
<li>GPU clusters are available and you have the operational expertise to manage GPU-aware orchestration</li>
<li>You need maximum throughput per hardware unit and are willing to invest in the infrastructure to achieve it</li>
</ul>
<p><strong>Choose Ollama if:</strong></p>
<ul>
<li>You value operational flexibility and the ability to experiment with different models without infrastructure changes</li>
<li>You deploy to edge nodes, Confidential Virtual Machines (CVMs), or other environments where GPU availability is uncertain</li>
<li>You need runtime model control — the ability to pull, swap, and delete models without restarting the inference service</li>
<li>You are cost-sensitive in the early stages of your AI deployment and want to validate your use case before committing to GPU infrastructure</li>
</ul>
<hr>
<h2 id="key-takeaway">Key Takeaway</h2>
<p>Cube AI eliminates the traditional trade-off between performance and flexibility by treating the LLM backend as an infrastructure plugin behind a clean proxy abstraction.</p>
<p>You do not need to commit to an inference engine early in your project. You can start with Ollama for development and proof-of-concept, validate your use case with real users and real data, and then evolve your backend to vLLM when concurrency and throughput requirements justify the GPU investment — all without changing a single line of application code.</p>
<p><strong>Start lightweight. Scale when necessary. Switch without friction.</strong></p>
<p>That is the power of backend modularity, and it is built into the foundation of Cube AI's architecture.</p>
<hr>
<p><em>Explore Cube AI's backend architecture in the <a href="https://docs.cube.ultraviolet.rs/getting-started">Deployment Guide</a> or learn more about <a href="https://docs.cube.ultraviolet.rs/architecture">Cube AI Architecture</a>.</em></p>
</div>

        <div class="mt-5 pt-4 border-top">
          
          <div>
            <a href="/blog" class="btn btn-outline-secondary"><i class="fas fa-arrow-left me-2"></i>Back to
              Blog</a>
          </div>
          <h5 class="mb-3 mt-3">Tags</h5>
          <div>
            
            <span class="badge bg-light text-dark me-2 mb-2 fs-6">architecture</span>
            
            <span class="badge bg-light text-dark me-2 mb-2 fs-6">devops</span>
            
            <span class="badge bg-light text-dark me-2 mb-2 fs-6">inference</span>
            
            <span class="badge bg-light text-dark me-2 mb-2 fs-6">vllm</span>
            
            <span class="badge bg-light text-dark me-2 mb-2 fs-6">ollama</span>
            
            <span class="badge bg-light text-dark me-2 mb-2 fs-6">cube ai</span>
            
          </div>
        </div>

        <div class="mt-4">
          <h5 class="mb-3">Share this article</h5>
          <div class="d-flex gap-2 flex-wrap">
            <a href="https://twitter.com/intent/tweet?text=vLLM&#43;vs&#43;Ollama&#43;in&#43;Cube&#43;AI%3A&#43;Choosing&#43;the&#43;Right&#43;LLM&#43;Backend&#43;for&#43;Your&#43;Use&#43;Case&url=https%3a%2f%2fwww.ultraviolet.rs/blog/vllm-vs-ollama-in-cube-ai"
              target="_blank" rel="noopener" class="btn btn-outline-dark btn-sm">
              <i class="fab fa-twitter me-2"></i>Twitter
            </a>
            <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3a%2f%2fwww.ultraviolet.rs/blog/vllm-vs-ollama-in-cube-ai"
              target="_blank" rel="noopener" class="btn btn-outline-dark btn-sm">
              <i class="fab fa-linkedin me-2"></i>LinkedIn
            </a>
          </div>
        </div>
      </div>
    </div>
  </article>

  
  <section id="newsletter" class="py-5">
    <div class="container">
      <div class="row mt-5 mb-5">
        <div class="col-md-6 offset-md-3 text-center">
          <h2>Subscribe to Our Newsletter</h2>
          <p>Stay updated with the latest news, updates and announcements.</p>

          
          <form
            action="https://ultraviolet.us20.list-manage.com/subscribe/post?u=b35e6bdc7b2adf06c56da2265&amp;id=88ed6c4af0&amp;f_id=004f06eaf0"
            method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="mt-4"
            target="_blank">
            <div class="input-group">
              <input type="email" class="form-control" name="EMAIL" placeholder="Enter your email" aria-label="Email"
                aria-describedby="subscribe-btn" required="" />
              <button class="btn btn-primary" type="submit" id="subscribe-btn">
                Subscribe
              </button>
            </div>
            <div style="position: absolute; left: -5000px" aria-hidden="true">
              <input type="text" name="b_b35e6bdc7b2adf06c56da2265_88ed6c4af0" tabindex="-1" value="" />
            </div>
          </form>
        </div>
      </div>
    </div>
  </section>
  

  
  
  <section class="py-5 bg-light">
    <div class="container">
      <h3 class="mb-4 fw-bold">Next Read</h3>
      <div class="row g-4">
        
        <div class="col-md-6 col-lg-4">
          <article class="card h-100 shadow-sm hover-lift border-0">
            <a href="/blog/prism-public-beta-launch" class="text-decoration-none text-dark">
              
              <img src="/img/prism-beta-launch-cover.png" class="card-img-top" alt="Prism AI Public Beta: Empowering Secure AI Collaboration"
                loading="lazy" onerror="this.style.display = 'none'" style="height: 200px; object-fit: cover;" />
              

              <div class="card-body">
                <div class="mb-2">
                  <span class="badge bg-success me-2">
                    announcement
                  </span>
                  
                </div>

                <h2 class="card-title h5 fw-bold">
                  Prism AI Public Beta: Empowering Secure AI Collaboration
                </h2>
                <p class="card-text text-muted small">
                  We are thrilled to announce the public beta release of Prism AI, our confidential computing platform for secure AI collaboration. Build and deploy privacy-preserving AI with hardware-verified security.
                </p>

                <div class="d-flex align-items-center mt-3">
                  <img src="https://avatars.githubusercontent.com/u/44265300?v=4" alt="sammy oina"
                    class="rounded-circle me-2" width="32" height="32" loading="lazy"
                    onerror="this.onerror=null; this.src = '/assets/team/default-avatar.jpg'" />
                  <div class="small">
                    <div class="fw-semibold">
                      sammy oina
                    </div>
                    <div class="text-muted">
                      February 12, 2026 · 3 min
                    </div>
                  </div>
                </div>

                <div class="mt-3">
                  
                  <span class="badge bg-light text-dark me-1">confidential-computing</span>
                  
                  <span class="badge bg-light text-dark me-1">ai</span>
                  
                  <span class="badge bg-light text-dark me-1">privacy</span>
                  
                  <span class="badge bg-light text-dark me-1">prism ai</span>
                  
                  <span class="badge bg-light text-dark me-1">beta-launch</span>
                  
                </div>
              </div>
            </a>
          </article>
        </div>
        
        <div class="col-md-6 col-lg-4">
          <article class="card h-100 shadow-sm hover-lift border-0">
            <a href="/blog/privacy-paradox-confidential-computing" class="text-decoration-none text-dark">
              
              <img src="/img/privacy-paradox/privacy-paradox.jpg" class="card-img-top" alt="The Privacy Paradox: Why AI Teams Should Care About Confidential Computing"
                loading="lazy" onerror="this.style.display = 'none'" style="height: 200px; object-fit: cover;" />
              

              <div class="card-body">
                <div class="mb-2">
                  <span class="badge bg-primary me-2">
                    blog
                  </span>
                  
                </div>

                <h2 class="card-title h5 fw-bold">
                  The Privacy Paradox: Why AI Teams Should Care About Confidential Computing
                </h2>
                <p class="card-text text-muted small">
                  AI teams face a growing privacy paradox: they must process highly sensitive data at cloud scale while traditional architectures leave data in use exposed. This post explains how confidential computing and TEEs close that gap for enterprise AI workloads.
                </p>

                <div class="d-flex align-items-center mt-3">
                  <img src="https://avatars.githubusercontent.com/u/41241359?v=4" alt="Jilks Smith"
                    class="rounded-circle me-2" width="32" height="32" loading="lazy"
                    onerror="this.onerror=null; this.src = '/assets/team/default-avatar.jpg'" />
                  <div class="small">
                    <div class="fw-semibold">
                      Jilks Smith
                    </div>
                    <div class="text-muted">
                      February 16, 2026 · 8 min
                    </div>
                  </div>
                </div>

                <div class="mt-3">
                  
                  <span class="badge bg-light text-dark me-1">confidential-computing</span>
                  
                  <span class="badge bg-light text-dark me-1">ai-security</span>
                  
                  <span class="badge bg-light text-dark me-1">privacy</span>
                  
                  <span class="badge bg-light text-dark me-1">tee</span>
                  
                  <span class="badge bg-light text-dark me-1">enterprise-ai</span>
                  
                  <span class="badge bg-light text-dark me-1">cube ai</span>
                  
                </div>
              </div>
            </a>
          </article>
        </div>
        
        <div class="col-md-6 col-lg-4">
          <article class="card h-100 shadow-sm hover-lift border-0">
            <a href="/blog/cocos-prism-release" class="text-decoration-none text-dark">
              

              <div class="card-body">
                <div class="mb-2">
                  <span class="badge bg-primary me-2">
                    blog
                  </span>
                  
                </div>

                <h2 class="card-title h5 fw-bold">
                  Unleashing Confidential AI: Cocos v0.8.0 and Prism v0.6.0 Released
                </h2>
                <p class="card-text text-muted small">
                  Ultraviolet releases Cocos AI v0.8.0 and Prism v0.6.0, enhancing the confidential computing ecosystem. These updates bring improved attestation, stronger security, and a better enterprise experience.
                </p>

                <div class="d-flex align-items-center mt-3">
                  <img src="https://avatars.githubusercontent.com/u/44265300?v=4" alt="sammy oina"
                    class="rounded-circle me-2" width="32" height="32" loading="lazy"
                    onerror="this.onerror=null; this.src = '/assets/team/default-avatar.jpg'" />
                  <div class="small">
                    <div class="fw-semibold">
                      sammy oina
                    </div>
                    <div class="text-muted">
                      February 06, 2026 · 4 min
                    </div>
                  </div>
                </div>

                <div class="mt-3">
                  
                  <span class="badge bg-light text-dark me-1">confidential-computing</span>
                  
                  <span class="badge bg-light text-dark me-1">ai</span>
                  
                  <span class="badge bg-light text-dark me-1">cocos ai</span>
                  
                  <span class="badge bg-light text-dark me-1">prism ai</span>
                  
                  <span class="badge bg-light text-dark me-1">privacy</span>
                  
                </div>
              </div>
            </a>
          </article>
        </div>
        
      </div>
    </div>
  </section>
  

  
  <footer class="bg-dark text-white py-3">
    <div class="container">
      <div class="row mt-3 mb-2">
        <div class="col">
          <h3>About Us</h3>
          <p class="w-65">
            Ultraviolet is a leading company specializing in confidential
            computing, cloud security, AI/ML, multi-party computation, and
            secure data sharing.
          </p>
        </div>

        <div class="col">
          <h3>Products</h3>
          <ul class="list-unstyled">
            <li>
              <i class="fas fa-network-wired me-2"></i><a href="prism/" class="text-white">Prism AI</a>
            </li>
            <li>
              <i class="fas fa-cog me-2"></i><a href="cocos/" class="text-white">Cocos AI</a>
            </li>
            <li>
              <i class="fas fa-cube"></i>
              <a href="cube/" class="text-white">Cube AI</a>
            </li>
          </ul>
          <h3>Resources</h3>
          <ul class="list-unstyled">
            <li>
              <a href="https://docs.google.com/presentation/d/199CkKD4YpgfJ1CLWVyZ9TdmXLLvME7JHN4Kfjkbgmho/export/pdf"
                class="text-white">
                Prism AI Datasheet
              </a>
            </li>
            <li>
              <a href="https://docs.google.com/presentation/d/1oZDjQjuzNR8PeI1AHS8tePaiA73SmjnjrFFEBoS6b68/export/pdf"
                class="text-white">
                Cocos AI Datasheet
              </a>
            </li>
            <li>
              <a href="https://docs.google.com/presentation/d/1UJR6HKiBV3r56SyMNZvO3ylek8VFmNojbFkTC-bawBY/export/pdf"
                class="text-white">
                Cube AI Datasheet
              </a>
            </li>
          </ul>
        </div>
        <div class="col">
          <h3>Legal</h3>
          <ul class="list-unstyled">
            Prism AI
            <li>
              <a href="/prism/terms" class="text-white"> Terms of Service</a>
            </li>
            <li>
              <a href="/prism/privacy" class="text-white"> Privacy Policy</a>
            </li>
            <br />
            Cube AI
            <li>
              <a href="/cube/terms" class="text-white">Terms of Service</a>
            </li>
            <li>
              <a href="/cube/privacy" class="text-white">Privacy Policy</a>
            </li>
          </ul>
        </div>
        <div class="col">
          <h3>Connect With Us</h3>
          <ul class="list-unstyled">
            <li>
              <i class="fab fa-twitter me-2"></i><a href="https://twitter.com/ultravioletrs" class="text-white"
                target="_blank">Twitter</a>
            </li>
            <li>
              <i class="fab fa-linkedin me-2"></i><a href="https://www.linkedin.com/company/ultravioletrs"
                class="text-white" target="_blank">LinkedIn</a>
            </li>
            <li>

            <li>
              <i class="fab fa-github me-2"></i><a href="https://github.com/ultravioletrs" class="text-white"
                target="_blank">GitHub</a>
            </li>
          </ul>
        </div>
        <div class="col">
          <h3>Contact Us</h3>
          <p>
            <i class="fas fa-envelope me-2"></i><a href="mailto:info@ultraviolet.rs"
              class="text-white">info@ultraviolet.rs</a>
          </p>
          <p>
            <i class="fab fa-gitter me-2"></i><a href="https://app.gitter.im/#/room/#Ultraviolet_community:gitter.im"
              class="text-white" target="_blank">Chat on Gitter</a>
          </p>
          <p>
            <i class="fas fa-map-marker-alt me-2"></i>Bulevar Arsenija
            Carnojevica 103, 11000 Belgrade, Serbia
          </p>
        </div>
      </div>
    </div>
  </footer>
  


  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.10.2/umd/popper.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/js/all.min.js"></script>

  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-CH54M1Z8DY"></script>

  
  <script src="https://cdn.jsdelivr.net/npm/cookieconsent@3/build/cookieconsent.min.js" data-cfasync="false"></script>
  <script>
    function getCookie(name) {
      var b = document.cookie.match(
        "(^|[^;]+)\\s*" + name + "\\s*=\\s*([^;]+)",
      );
      return b ? b.pop() : "";
    }

    function addAnalytics() {
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-CH54M1Z8DY");
    }

    document.addEventListener("DOMContentLoaded", function () {
      
      const cookieConsent = getCookie("cookieconsent_status");

      
      if (cookieConsent === "allow" || cookieConsent === "") {
        addAnalytics();
      }

      if (typeof window.cookieconsent !== "undefined") {
        window.cookieconsent.initialise({
          palette: {
            popup: { background: "#000" },
            button: { background: "#f1d600" },
          },
          revokable: true,
          law: {
            regionalLaw: {
              EU: true, 
              UK: true, 
            },
          },
          location: true, 
          type: "opt-out",
          content: {
            message:
              "🍪 We use cookies to collect data to improve your experience on our site.",
            allow: "Allow",
            dismiss: "Allow",
            deny: "Reject",
          },
          onStatusChange: function (status, chosenBefore) {
            location.reload();
          },
        });
      } else {
        console.error("Cookie consent script not loaded.");
      }
    });
  </script>

  <script>
    
    document.addEventListener('DOMContentLoaded', async () => {
      
      if (typeof mermaid !== 'undefined') {
        mermaid.initialize({ startOnLoad: false, theme: 'default', logLevel: 'debug' });
      }

      
      const markdownContent = document.querySelector('.markdown-content');
      if (markdownContent) {
        const pres = markdownContent.querySelectorAll('pre');

        pres.forEach(pre => {
          const code = pre.querySelector('code');
          if (code && code.className.includes('language-mermaid')) {
            const mermaidDiv = document.createElement('div');
            mermaidDiv.className = 'mermaid';
            mermaidDiv.textContent = code.textContent;
            pre.replaceWith(mermaidDiv);
          }
        });
      }

      
      if (typeof mermaid !== 'undefined') {
        try {
          await mermaid.run();
        } catch (e) {
          console.error('Mermaid rendering error:', e);
        }
      }

      hljs.highlightAll();

      const pres = document.querySelectorAll('.markdown-content pre');

      pres.forEach(pre => {
        const wrapper = document.createElement('div');
        wrapper.className = 'code-wrapper';
        pre.parentNode.insertBefore(wrapper, pre);
        wrapper.appendChild(pre);

        const btn = document.createElement('button');
        btn.className = 'copy-button';
        btn.type = 'button';
        btn.innerHTML = '<i class="far fa-copy"></i>';
        btn.setAttribute('aria-label', 'Copy code to clipboard');
        btn.title = 'Copy code';

        wrapper.appendChild(btn);
      });
    });

    document.addEventListener('click', async (e) => {
      const btn = e.target.closest('.copy-button');
      if (!btn) return;

      const pre = btn.parentElement.querySelector('pre');
      const code = pre.querySelector('code') || pre;
      const text = code.textContent;

      try {
        if (navigator.clipboard && window.isSecureContext) {
          await navigator.clipboard.writeText(text);
        } else {
          
          const textarea = document.createElement('textarea');
          textarea.value = text;
          textarea.style.position = 'fixed';
          textarea.style.opacity = '0';
          document.body.appendChild(textarea);
          textarea.focus();
          textarea.select();
          document.execCommand('copy');
          document.body.removeChild(textarea);
        }

        btn.innerHTML = '<i class="fas fa-check"></i>';
        btn.classList.add('copied');
        btn.title = 'Copied!';

        setTimeout(() => {
          btn.innerHTML = '<i class="far fa-copy"></i>';
          btn.classList.remove('copied');
          btn.title = 'Copy code';
        }, 2000);

      } catch (err) {
        console.error('Copy failed', err);
        btn.innerHTML = '<i class="fas fa-times"></i>';
        setTimeout(() => btn.innerHTML = '<i class="far fa-copy"></i>', 2000);
      }
    });
  </script>

</body>

</html>
